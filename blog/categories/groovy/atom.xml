<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Blog de MakingDevs]]></title>
  <link href="http://blog.makingdevs.com/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://blog.makingdevs.com/"/>
  <updated>2015-08-16T22:39:50-05:00</updated>
  <id>http://blog.makingdevs.com/</id>
  <author>
    <name><![CDATA[MakingDevs]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Amazon S3 Y Groovy]]></title>
    <link href="http://blog.makingdevs.com/2015/08/13/amazon-s3-y-groovy/"/>
    <updated>2015-08-13T22:47:08-05:00</updated>
    <id>http://blog.makingdevs.com/2015/08/13/amazon-s3-y-groovy</id>
    <content type="html"><![CDATA[<p>En una de las tareas que realice recientemente, tuve la necesidad de transferir un par de archivos que obtuve de un endpoint(de la cual hablaré en otro post) hacia un Bucket de Amazon S3.</p>

<p>La solución inmediata fue usar una biblioteca que encontré para Java de nombre <a href="http://www.jets3t.org/">jets3t</a>, la cual, provee de un conjunto de herramientas muy simple para operar con Amazon S3, Cloud Front y Google Storage.</p>

<p>El caso muy puntual que tuve que resolver fue subir un archivo y despúes borrarlo de un bucket muy particular. En este ejemplo muestro primero como listar todos los buckets disponibles en una cuenta de S3.</p>

<!-- more -->


<pre><code class="groovy">@Grapes(
    @Grab(group='net.java.dev.jets3t', module='jets3t', version='0.9.3')
)

import org.jets3t.service.security.*
import org.jets3t.service.*
import org.jets3t.service.impl.rest.httpclient.*
import org.jets3t.service.model.*
import org.jets3t.service.acl.*

String awsAccessKey = "YOURAWSACCESSKEY"
String awsSecretKey = "YOURAWSSECRETKEY"

AWSCredentials awsCredentials = new AWSCredentials(awsAccessKey, awsSecretKey)
S3Service s3Service = new RestS3Service(awsCredentials)

S3Bucket[] myBuckets = s3Service.listAllBuckets()
</code></pre>

<p>Despúes una vez con todos los buckets, podemos listar los archivos contenidos dentro de uno muy particular.</p>

<pre><code class="groovy">String bucletName = "makingdevs-bucket"

bucket = myBuckets.find { it.name==bucketName }

s3Objects = s3Service.listObjects(bucket)
</code></pre>

<p>Finalmente, podemos subir un archivo en particular hacia el bucket que deseamos.</p>

<pre><code class="groovy">
file = new File("/some/file/in/your/filesystem.ext")

S3Object s3Object = new S3Object()
s3Object.with {
  acl AccessControlList.REST_CANNED_PUBLIC_READ
  contentLength file.length()
  contentType file.toURL().openConnection().contentType
  dataInputFile file
  key file.name
  bucketName bucket.getName() // we use our previous bucket
}

s3Service.putObject bucket, s3Object
</code></pre>

<p>Una vez que llamamos al servicio <code>s3Service</code> el archivo queda colocado en el bucket. Y finalmente si deseamos borrarlo podemos usar <code>s3Service.deleteObject s3Bucket, s3Object.key</code>, en donde sólo mandamos el objeto del bucket y el <em>key</em> del objeto que deseamos borrar.</p>

<p>Finalmente, me gustaría detallar dos líneas que en mi opinión son relevantes:</p>

<ul>
<li>La parte de <code>acl AccessControlList.REST_CANNED_PUBLIC_READ</code>, la cual indica que el archivo que se sube es de acceso público para quién quiera que tenga la URL y sólo el propietario puede modificar, existen otras constantes que dan combinaciones de permisos distintos en <a href="http://www.jets3t.org/api/org/jets3t/service/acl/AccessControlList.html">la documentación de JetS3t</a>.</li>
<li>La línea con <code>contentType file.toURL().openConnection().contentType</code> que es una forma de obtener el <em>content type</em> sin la necesidad de una biblioteca adicional, sólo con el uso convencional de las clases Java con las que ya contamos. Les recomiendo tomar cualquier archivo y probar sólo esa línea.</li>
</ul>


<p>Si bien hay más cosas que se pueden hacer, les sugiero se den una vuelta por la documentación de esta biblioteca.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hot Deployment en Gradle]]></title>
    <link href="http://blog.makingdevs.com/2015/07/26/hot-deployment-en-gradle/"/>
    <updated>2015-07-26T23:19:13-05:00</updated>
    <id>http://blog.makingdevs.com/2015/07/26/hot-deployment-en-gradle</id>
    <content type="html"><![CDATA[<p>Durante un tiempo estuve buscando de la forma de tener una aplicación web con Gradle y tener características como el hot deploy, Grails lo tiene y viendólo de forma interna usa un elemento de nombre <a href="https://github.com/spring-projects/spring-loaded" title="springloaded">SpringLoaded</a>.</p>

<p>Después me di cuenta que frameworks como <a href="https://github.com/spring-projects/spring-loaded" title="dropwizard">Dropwizard</a> lo usan, y que incluso SpringBoot a través del uso del CLI también, investigando un poco más al respecto y por la necesidad de tenerlo listo para algunos proyectos encontré <a href="http://www.cholick.com/entry/show/280" title="tomcat">un artículo</a> en donde explica como ponerlo en acción usando propiamente <a href="https://github.com/spring-projects/spring-loaded" title="dropwizard">Dropwizard</a>. Fue un buen acercamiento, el problema es el siguiente bloque de código en configuración de gradle:</p>

<!-- more -->


<pre><code class="groovy">run {
  args = ['server', 'app.yaml']
  jvmArgs = ["-javaagent:${new File("$buildDir/agent/springloaded-${springloadedVersion}.jar").absolutePath}", '-noverify']
}
</code></pre>

<p>En donde, el atributo <code>jvmArgs</code> es sólo aplicable a tareas del tipo <code>JavaExec</code>, más específico, que implementan <code>JavaExecSpec</code> o <code>JavaForkOptions</code>. Es aquí en donde <a href="https://github.com/bmuschko/gradle-tomcat-plugin" title="tomcat">el plugin de tomcat</a> que se puede encontrar para Gradle tiene el problema, pues su tarea no lo hace.</p>

<p>La combinación se haría en conjunto con un plugin de gradle, <a href="https://github.com/bluepapa32/gradle-watch-plugin" title="gradle watch">el watch</a>, el actúa con cada cambio en la aplicación realizando las tareas que se le digan. Sin embargo, lo que encontré funcionaba para la cmbinación de SpringBooy e IntelliJ Idea, lo cual no veía mal, pero no era mi caso. De cualquier forma pongo disponible la configuración que independiente me sirvió para hacer un hot deploy usando ambos elementos:</p>

<pre><code class="groovy">apply plugin: 'groovy'
apply plugin: 'spring-boot'
apply plugin: 'com.bluepapa32.watch'

sourceCompatibility = 1.8
targetCompatibility = 1.8

ext {
  springLoadedVersion = '1.2.1.RELEASE'
}

mainClassName='com.makingdevs.Application'

repositories {
  mavenCentral()
  maven {
    url "https://code.lds.org/nexus/content/groups/main-repo"
  }
}

dependencies {
  compile("org.springframework.boot:spring-boot-starter-web")
  compile 'org.codehaus.groovy:groovy-all:2.4.3'
}

buildscript {
  repositories {
    mavenCentral()
    jcenter()
  }
  dependencies {
    classpath "org.springframework.boot:spring-boot-gradle-plugin:1.2.4.RELEASE"
    classpath 'org.springframework:springloaded:1.2.0.RELEASE'
    classpath 'com.bluepapa32:gradle-watch-plugin:0.1.5'
  }
}

jar {
  baseName = 'meerkat-mymapmanager'
  version =  '0.1.0'
}

compileGroovy {
  //enable compilation in a separate daemon process
  options.fork = true
}

watch {
  groovy {
    files files('src/main/groovy')
    tasks 'compileGroovy'
  }
}
</code></pre>

<p>Al final del día, lo que encontre fue <a href="http://akhikhl.github.io/gretty-doc/index.html" title="gretty">el plugin de Gretty</a>, con el que fácilmente podemos usar un contenedor de Tomcat o Jetty y tener disponible el Hot deploy, creo que tiene algunos detalles de rendimiento pero es útil. Finalmente la configuración se reduce mucho y hay varias tareas disponibles, entre ellas <code>appRun</code>, que es la que levanta el elemento configuraco y lo dijo listo para los cambios:</p>

<pre><code class="groovy">// Using the new mechanism to include plugins
plugins {
  id 'groovy'
  id 'war'
  id "org.akhikhl.gretty" version "1.2.4"
}

repositories {
  mavenCentral()
  jcenter()
}

dependencies {
  compile 'org.codehaus.groovy:groovy-all:2.3.4'
}

gretty {
  // 'jetty7', 'jetty8', 'jetty9', 'tomcat7', 'tomcat8'
  servletContainer = 'tomcat7'
  httpPort = 9091
}
</code></pre>

<p>Creo que nos servirá bien un rato para las cosas que tenemos que hcaer, por que incluso soporta SpringBoot.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Borrado Batch en Grails]]></title>
    <link href="http://blog.makingdevs.com/2015/05/01/borrado-batch-en-grails/"/>
    <updated>2015-05-01T20:58:30-05:00</updated>
    <id>http://blog.makingdevs.com/2015/05/01/borrado-batch-en-grails</id>
    <content type="html"><![CDATA[<p>En esta ocasión les quiero compartir la solución a un problema que tuve al borrar una colección de objetos en grails y con el GORM, si bien podría hacerlo con HQL o con SQL usando las bondades de Hibernate me gusto más el acercamiento que les quiero presentar.</p>

<!-- more -->


<p>La necesidad era borrar un grupo de objetos en donde el contenido de su relación estuviera vacío, ejemplifico con la estructura de unas clases:</p>

<p><div><script src='https://gist.github.com/54953d90cc778b71548a.js?file=domains.groovy'></script>
<noscript><pre><code>class Group {
  String name
  
  static hasMany = [members : Member]
}

class Member {
  String name
}</code></pre></noscript></div>
</p>

<p>El primer acercamiento que tuve fue obtener la lista de elementos y hacer una condicional buscando los elementos vacíos, después borrar&hellip;</p>

<p><div><script src='https://gist.github.com/54953d90cc778b71548a.js?file=delete1.groovy'></script>
<noscript><pre><code>groupsToDelete = [] 
Group.list().each { group -&gt; 
  if(group.members.isEmpty()) 
    groupsToDelete &lt;&lt; link
} 
groupsToDelete*.delete() </code></pre></noscript></div>
</p>

<p>Una vez hecho, mejoramos intentamos mejorar el código con una búsqueda mucho más refinada y ejecutando el borrado, para ello nos apoyamos de los <strong>where queries</strong>:</p>

<p><div><script src='https://gist.github.com/54953d90cc778b71548a.js?file=delete2.groovy'></script>
<noscript><pre><code>Group.where { 
  members.size() == 0 
}.deleteAll()</code></pre></noscript></div>
</p>

<p>Basado en la documentación de Grails:</p>

<blockquote><p>Since each where method call returns a DetachedCriteria instance, you can use where queries to execute batch operations such as batch updates and deletes.</p></blockquote>

<p>Sin embargo, este acercamiento tiene un problema, manda un error cuando se busca por las relaciones del objeto y no permite el borrado. El error: <code>org.springframework.dao.InvalidDataAccessResourceUsageException: Queries of type SizeEquals are not supported by this implementation</code></p>

<h3>La solución que me gustó</h3>

<p>Usamos <strong>Detached Criteria</strong> para resolver este problema, por que:</p>

<ul>
<li>No están asociados con una sesión o conexión, lo cual permite formularlos y reusarlos.</li>
<li>También cuenta con métodos batch: <code>deleteAll</code>, <code>updateAll</code></li>
<li>Permiten proyecciones y subqueries, que es lo que estamos buscando para resolver nuestro problema</li>
</ul>


<p>Finalmente nuestra solución es:</p>

<p><div><script src='https://gist.github.com/54953d90cc778b71548a.js?file=delete3.groovy'></script>
<noscript><pre><code>import grails.gorm.*

def criteria = new DetachedCriteria(Group).build { 
  isEmpty &#39;members&#39;
}
criteria.deleteAll()
// criteria.count()</code></pre></noscript></div>
</p>

<p>Con esto, tenemos una búsqueda refinada y el borrado de los elementos directo, inclusive el método <code>deleteAll</code> regresa un entero con la cantidad de registros afectados.</p>

<p>Esto me fue de mucha utilidad y ojalá también lo sea para ustedes en algún momento.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inyección De Métodos Por Categorías Y TimeCategory]]></title>
    <link href="http://blog.makingdevs.com/2014/09/16/inyeccion-de-metodos-por-categorias-y-timecategory/"/>
    <updated>2014-09-16T18:55:30-05:00</updated>
    <id>http://blog.makingdevs.com/2014/09/16/inyeccion-de-metodos-por-categorias-y-timecategory</id>
    <content type="html"><![CDATA[<h2>Acerca de las categorías</h2>

<p>En Groovy se pueden inyectar métodos de algunas formas, uno de ellos es a través del uso de categorías, la cual nos da inyección temporal y controlada de dichos elementos. Para hacerlo las clases que son categorías deben de cumplir con cierta estructura:</p>

<ul>
<li>Los métodos de la clase deben ser definidos como estáticos</li>
<li>El primer argumento de dicho método define el tipo sobre el cual se inyectarían los nuevos métodos</li>
<li>Deben de ser usados dentro del alcance de un closure con ayuda de la palabra reservada <code>use</code></li>
</ul>


<!-- more -->


<p>Un ejemplo podría ser el siguiente:</p>

<pre><code class="groovy">    class NameUtil{
        static prettify(String name){
            name.trim().split(' ').grep { it.size() }*.capitalize().join(' ')
        }
    }

    use NameUtil, {
        println "  josé   juan    reyes    zuñiga   ".prettify()
    }
</code></pre>

<p>Adicionalmente, podemos crear dicha inyección de métodos con ayuda de la anotación <code>@Category</code>, que prácticamente nos facilita a que cualquier clase pueda ser usada como categoría, pues no necesariamente los métodos tiene que ser estáticos y el contexto del argumento para la inyección es el objeto <code>this</code> en donde se esté intentando usar.</p>

<h2>Uso de GroovyTime</h2>

<p>La clase <code>TimeCategory</code> es una clase que tiene una serie de métodos de conveniencia para el manejo del tiempo, formando así un DSL, con el que podemos operar. Y con ayuda de la clase <code>Duration</code> complementamos algunas operaciones que se pueden realizar en el contexto de los objetos que estemos usando.</p>

<pre><code class="groovy">    import groovy.time.TimeCategory

    use ( TimeCategory ) {
        println 2.hours.ago
        println 30.minutes.from // TimeDuration
        println 30.minutes.from.now
        println 40.minutes + 30.minutes.from.now
        println 30.minutes.ago

        def today = new Date()
        println today - 3.years
        println today + 4.weeks
        println today + 90.minutes
    }
</code></pre>

<p>Para que consideres el conjunto de operaciones que tienes disponibles te recomendamos visitar la documentación de <a href="http://groovy.codehaus.org/api/groovy/time/TimeCategory.html">TimeCategory</a> y <a href="http://groovy.codehaus.org/api/groovy/time/Duration.html">Duration</a></p>
]]></content>
  </entry>
  
</feed>
